# Lecture 4 Applications of scan

## Applications of scan

### Compact (filter)

e.g. 1, 2, 3, 4, 5, 6, 7 -> 2, 4, 6 ("filter" even numbers)

**Algorithm:**

* Compute predicates by map,  e.g. in above we get 0, 1, 0, 1, 0, 1, 0

* Exclusive sum scan predicates, e.g. in above, we get 0, 0, 1 1, 2, 2, 3

* Scatter input into output

### Allocate

e.g. allocate memory for triangles generated by cropping a triangle mesh with a screen

Each triangle may generate up to 5 triangles, allocating max possible memory can waste a lot of space

**Algorithm:**

* Use map to compute the amount of space required by each element

  \(e.g. \#triangle generated by each input triangle\)

* Exclusive sum scan of the map results gives location of array to write in output

### Segmented scan

* Goal: Many small scans, lauch each independently, then combine them as segments

* Representation: in addition to input array, also a binary "segment head" array with 1 marking segment heads

e.g. 1 2 \| 3 4, segment head is 1 0 1 0

### SPMV -- SParse matrix Multiply (dense) Vector

**Sparse matrix representation: **

* v : value of nonzero elements

* c : columns of nonzero elements

* r : row pointer

**Algorithm:**

* Create segmented representations from value and row pointers
* Gather vector values using columns
* Pairwise multiply using map
* Inclusive segmented sum scan (easier from backward so that sum appears at row ptr)

## Sorting algorithms

### Brick sort (Bubble sort)

**Algorithm**

Repeat:
1. Swap a0 and a1, a2 and a3, …. to make pairs in order
2. Swap a1 and a2, a3 and a4, … to make pairs in order
Until no swap occurs

### Merge sort

**Algorithm for merging sorted arrays:**

1. Extract splitters of the two sorted arrays
2. Sort them
3. Put numbers into bins seperated by splitters
4. Sort each bin

Each output bin size is less than sum of bin size in the two list

Example:

![](/Udacity344/notes/images/Lec4_merge.png)

### Sorting network

**Pro: oblivious** -- behavior is independent of certain aspects of alg. (e.g. input)

Example: (sorting 8 numbers)

![](/Udacity344/notes/images/Lec4_sorting_network.png)

Idea: assume two lists l1, l2 are sorted, then [l1, l2] is bitonic sequence (i.e. direction only changes at most once)

**Algorithm for sorting bitonic sequence:**

* Take pairwise max and min of l1 and l2
* Recurse to sort min part and max part (both are still bitonic sequence)
* There are other possible sorting networks: e.g. odd-even sort network

### Radix sort

Work Complexity: O(kn) ~O(n) times, where k is #bits, n is #element

**Algorithm:**

1. for b = least significant bit : most sigifnicant bit
2. Split input into two sets, preserve order within each set

Implementation of split: compact on bit value

###Quick sort

Similar to radix sort's split step to implement three-way partition:
* Distribute pivot to each element
* Map to get relationship
* Compact and scatter

###Key-value sort

Input pointers or 64-bit structures

